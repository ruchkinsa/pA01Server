1+) именование переменных: 	var cryptoSetting cryptoSettings - ok	var u User - bad2+) Вынести модели в отдельный файл (не модуль, а файл)	3+) Закрыть коннект к бд перед закрытием программы4+) type resultJSON struct {} вынести в отдельный тип из функций5) сделать функции короче - высотой в экран (createTablesIfNotExist)6+) не передавать кучу полей в функцию, а объединить в отдельный тип и передавать его экземпляр7) потестить сохранение полей ключа в бд в json (MySQL 5.7 теперь предоставляет тип данных JSON)8) e,hfnm prepareSqlStatementsАлгоритм обмена сообщениями между сервером лицензий (Server) и клиентскими приложениями (Client):	Каждый проект (Product) имеет свои приватные (Product.PrivateKey) и публичные (Product.PublicKey) ключи	Каждая лицензия (экземпляр проекта, License) имеет свои приватные (lic.PrivateKey) и публичные (lic.PublicKey) ключи, а также знает Product.PublicKey	I. Запрос на активацию ключа (при установке Client):		1. Client посылает запрос на Server, сообщая свой lic.PublicKey.		2. Server ищет License.ID по lic.PublicKey:			а) Не находит: тогда делает запись в Log, отсылает (шифрованный) ответ Client.			б) Найден: проверяется стутус и тип лицензии:				a. Лицензия блокирована, например истек срок действия, то тогда делает запись в Log, отсылает (шифрованный) ответ Client.				b. Лицензия активна, тогда переход на пункт 3.		3. Server вырабатывает новый ключ и его сигнатуру, используя шифрование:			lic.Key = crypto(secretText, lic.PublicKey)			lic.Signature = crypto(secretText, Product.PrivateKey)		4. Server отправляет lic.Key, lic.Signature на Client.		5. Client расшифровывает secretText, используя lic.PrivateKey, и проверяет подпись (lic.Signature), используя Product.PublicKey:			а) если подпись верна, то активируется лицензия с ключом lic.Key и отсылается сообщение на сервер об успешной активации. Переход к пункту 6.			б) если подпись не верна, то пользователю сообщяется об ошибке и предлагается повторить попытку или обратиться в support, и отсылается сообщение на сервер об ошибке активации. Переход к пункту 6.		6. Server делает запись в Log о результате попытки активации. Если активация прошла успешно, то меняет информацио о лицензии: перезаписывает ключ lic.Key, статус и срок действия лицензии.						II. Запрос на подлинность ключа (при запуске Client):		1. Client посылает запрос на Server, сообщая свой lic.PublicKey и lic.Key.		2. Server ищет License.ID по lic.PublicKey:			а) Не находит: тогда делает запись в Log, отсылает (шифрованный) ответ Client.			б) Найден: проверяется стутус и тип лицензии:				a. Лицензия блокирована, например истек срок действия, то тогда делает запись в Log, отсылает (шифрованный) ответ Client.				b. Лицензия активна, тогда переход на пункт 3.		3. Server проверяет lic.Key:					а) Не совпадает: тогда делает запись в Log, отсылает (шифрованный) ответ Client. Переход к пункту 4.			б) Совпадает: тогда делает запись в Log, отсылает (шифрованный) ответ Client. Переход к пункту 5.		4. Пользователь уведомляется, что более поздний ключ анулируется, так как выданная лицензия активирована повторно, поэтому продолжение работы невозможно.		5. Пользователь продолжает работу.					Log - журнал событий, может быть реализован в виде таблицы БД	secretText - текст (набор бит), используемых для выработки ключа, должен быть уникальным для каждого случая попытки создания (активации) ключей